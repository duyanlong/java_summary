

微服务归约

## 有意义的对象

**PO**

persistant object 持久化对象，在OR Mapping映射的时候出现的概念，如果没有OR Mapping映射，就没有这个概念存在了。PO对应数据库中的实体表，PO中不应该包含任何对数据库的操作。

最形象的理解就是一个PO就是数据库中的一条记录，好处是可以把一条记录作为一个对象处理，可以方便的转为其他对象。

**VO**

主要对应界面展示的数据对象。对于一个WEB页面，或者SWT、SWING的一个界面，用一个VO对象对应整个界面的值

**DTO**

data transfer object 数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，在微服务中泛指用于展示层与服务层之间的数据传输对象

比如我们一张表有100个字段，那么对应的PO就有100个属性，但是我们界面上只要显示10个字段，客户端用web service来获取数据，没有必要把整个PO对象传递到客户端，这时我们就可以用只有10个属性的DTO来传递结果到客户端，这样也不会暴露服务端表结构，到达客户端以后，如果用这个对象来对应界面显示，那此时它的身份就转为VO

**POJO**

plain ordinary java object 传统意义的java对象。只有属性字段及setter和getter方法

POJO是多变的，泛指java对象，一个POJO持久化以后就会PO，直接用它传递、传递过程中就是DTO、直接用来对应表示层就是VO

**DAO**

data access object 数据访问对象，负责持久化的操作。此对象用于访问数据库。通常和PO结合使用，DAO中包含了各种数据库的操作方法。通过它的方法，结合PO对数据库进行相关的操作

DAO会比较熟悉，主要用来封装对数据库的访问。通过它可以把POJO持久化为PO，用PO组装出来VO、DTO

**BO**

business object 业务对象，主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其他的对象。比如一个简历，有教育经历、工作经历、社会关系等等。我们可以把教育经历对应一个PO，工作经历对应一个PO，社会关系对应一个PO。建立一个对应简历的BO对象处理简历，每个BO包含这些PO。这样处理业务逻辑时，我们就可以针对BO去处理。

**DO**

domain object 领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。

## 有意义的命名

- [ ] [强制] 常量类命名：Constants.java，常量必须添加注释（不建议有全局常量类！）
- [ ] [强制] 配置类命名：XxConfig.java，配置类命名必须要与技术名称一致，如SwaggerConfig.java
- [ ] [强制] controller命名：XxController.java，严格避免业务代码侵入
- [ ] [强制] dao命名：XxMapper.java Xx对应实体名称
- [ ] [强制] service命名：XxService.java 方法必须注释，impl： XxServiceImpl.java 具体实现类

## 有意义的校验
**此处暂不涉及**  
XxDto.java

```java
// 属性值注释
@ApiModelProperty("用户名")
// 参数校验，message为错误提示信息
@NotNull(message="用户名不能为空")
@Size(min=5,max=10,message="用户名长度应在5-10位之间")
// 校验类型详情查看源码：javax.validation.constraints
```

常规校验包括：

- ID为整型校验
- 必填项非空校验
- 字段长度校验
- “状态”字段取值范围，在DTO中校验

```java
@PathParam("id") @NotEmpty String id，// 可以用这种方式添加校验，而非必须在DTO中添加校验  
```

## 合理的Controller

```java
@Api(description = "配置管理 - 分类管理")
@CrossOrigin // 去掉跨域注解，由前端统一解决。或后端统一解决
@RestController
@RequestMapping(value = "/config")
public class CategoryController {
	.....
}
```

```java
/**
 * 创建模型.
 */
@ResponseBody
@ApiOperation(value = "增加", notes = "传入json对象")
@RequestMapping(value = "/logic", method = RequestMethod.POST, consumes = "...")
public ResultObject createModel(@RequestBody ModelDto modelDto) throws InnerSystemException {
    return BaseResponse.formatSuccessResponse(modelService.insert(modelDto));
}
// 理论上，在Controller中不允许有 throws InnerSystemException，考虑要去掉。
```

```java
// 在Controller中去掉对异常的捕获，异常统一用@ControllerAdvice处理
try {
	CategoryDto categoryDto = qdamCategoryService.selectByCategoryId(id);
	return BaseResponse.formatSuccessResponse(categoryDto);
} catch (InnerSystemException ex) {
	return BaseResponse.formatInnerExceptionResponse(ex);
}
```

```java
public ResultObject delete(@RequestParam("id") Long id) {
	int resultCode = qdamCategoryService.delete(id);
	if (resultCode == 0) { // 这个逻辑，放到Service中去做，抛出DataNotExistEception异常
		return BaseResponse.formatDataNotExistedResponse("");
	} 
    return BaseResponse.formatSuccessResponse(resultCode);
}
```

```java
@RequestMapping(value = "/qdam_data_asset_fields")
// 禁止将表名，作为rest请求的路径，路径不要暴露表名
```

```java
@RequestParam(value = "modelId", required = false)，
// 将modelId改为model_id，url路径中不允许出现大写
```

建议Controller只有两行代码，一行调用service、一行返回结果。

## 返回实体信息

在controller中统一使用ResultObject组装返回给客户端的具体内容。

code：

```java
public enum ErrorCodeEnum{
    SUCCESS(200,"成功"),
    ILLEGAL_REQUEST(400,"非法请求"),
    NOT_AUTHORIZATION(401,"未授权"),
    NOT_SUCCESS(402,"请求失败"),
    ILLEGAL_PARAM(403,"参数异常"),
    FALL_BACK(405,"断路返回"),
    SERVER_ERROR(500,"服务器异常");
}
```

```java
public class ResultObject{
    private String message;
    private int code;
    private Object data;
    .....
}
```

## 合理的Service

- [ ] [强制] 业务逻辑代码出现在Service中，而不是Controller或DAO中
- [ ] [强制] 记录日志，统一使用监控系统提供的规范
- [ ] [强制] info及以上禁止输出大对象，但必须打印关键参数，参数使用"{}"占位符而不是用"+"字符串拼接
- [ ] [强制] 方法体职责单一，减少嵌套层数
- [ ] [强制] 禁止魔法值，尽量使用枚举类型替代静态常量，尤其是status等描述状态的字段，不能在代码中将值写死
- [ ] [强制] 禁止使用类似Constants的全局常量类，领域对象相关的常量在对象实体类中定义，与业务逻辑相关的常量在对应的service中定义
- [ ] [强制] 在根据ID，执行删除或修改的操作中，首先需要判断这条记录是否存在，如果不存在，返回异常信息为：数据不存在
- [ ] [强制] getIdentifyNameByDataTypeFromSysDimIdentify()，方法名要求动词，且能读的出来
- [ ] [强制] 接口方法不要使用public 描述，.e.g.： int insert(xx) 
- [ ] [强制] 正常情况下，代码中不要有throws SQLException，除非是第三方API抛出的
- [ ] [强制] service插入操作，统一返回值为主键ID
- [ ] [强制] 对前端提供的接口，不要是细粒度的接口，防止一个页面中出现调用十几个接口的情况。

```java
public List getLogicNameByNameFromSysCommonField(String name) { 
    SysCommonField sysCommonField = new SysCommonField(); 
    sysCommonField.setName(name); 
    List sysCommonFieldList = sysCommonFieldMapper.selectSelectiveLike(sysCommonField);
	List logicNameList = new ArrayList<>(); 
    for (SysCommonField commonField : sysCommonFieldList) {
		logicNameList.add(commonField.getLogicalName()); 
    } 
    return logicNameList;
}
// 虽然前端可能只需要LogicalName，但是不要单独返回List<String>，而是List<Dto>。
// 未来在从这个表中取其他的信息，可以直接从这个接口中取。同时也控制了后端接口的数量，不至于膨胀的过大。
```

- [ ] [强制] DEFAULT 'N/A'，允许为空的字段，在设计表的时候，都添加了默认值，所以在代码中尽量不要判断null，方法返回值不允许返回null，方法入参不允许传递null



## 合理的异常处理

- [ ] [强制] 如果没有业务逻辑处理，则不要捕获异常，service层避免仅为打印异常的try-catch
- [ ] [强制] 在线程边界必须捕获异常输出日志，异常日志输出必须打印堆栈，并打印关键参数
- [ ] [强制] 使用ControllerAdvice拦截所有异常，做异常信息转换，不能直接抛出SQLException到前端，防止后端表信息泄露
- [ ] [强制] 如果使用异步线程或者自建线程池，必须在线程发起的入口捕获所有异常，并打印日志



 ## 接口规定

### 使用名词而不是动词

使用RestFul API接口；URL中不要使用动词，如GET，ADD，CREATE等。

| Resource资源 | GET 读        | POST 创建           | PUT 修改           | DELETE 删除    |
| ------------ | ------------- | ------------------- | ------------------ | -------------- |
| /cars        | 返回cars集合  | 创建新的资源        | 批量更新cars       | 删除所有cars   |
| /cars/711    | 返回特定的car | 该方法不允许（405） | 更新一个指定的资源 | 删除指定的资源 |

不要使用：

/getAllCars

/createNewCar

/deleteAllRedCars

------

**Method**

- GET：查询资源
- POST：创建资源
- PUT/PATCH
  - PUT：全量更新资源（提供改变后的完整资源）
  - PATCH：局部更新资源（仅提供改变的属性）
- DELETE：删除资源

**安全性与幂等性**

- 安全性：任意多次对同一资源操作，都不会导致资源的状态变化
- 幂等性：任意次对同一资源操作，对资源的改变是一样的

| Method | 安全性 | 幂等性 |
| ------ | ------ | ------ |
| GET    | √      | √      |
| POST   | ×      | ×      |
| PUT    | ×      | √      |
| PATCH  | ×      | √      |
| DELETE | ×      | √      |

------

**下面是常用的例子**：

- GET /zoos：列出所有动物园
- POST /zoos：新建一个动物园
- GET /zoos/ID：获取某个指定动物园的信息
- PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）
- PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）
- DELETE /zoos/ID：删除某个动物园
- GET /zoos/ID/animals：列出某个指定动物园的所有动物
- DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物

### URI设计技巧

- 不要用大写字母

```
http://www.ruanyifeng.com/blog/2014/05/restful_api.html
```

- 单词间用下划线分割

- 使用?用来过滤资源

- 使用/来表示资源的层级，不要超过三层

  ~~users/1/address/2/citys~~  (bad) 

  /citys?users=1&address=2	(good)

- 使用`,`或者`;`来表示同级资源的关系

### Get方法不应该涉及状态改变

使用PUT、POST和DELETE方法而不是GET方法来改变状态，不要使用GET进行状态改变：

GET /users/711?active

GET /users/711/active

### 使用复数名词

不要混淆名词单数和复数，为了保持简单，对所有资源使用复数

/cars 而不是 /car

/users 而不是 /user

/products 而不是 /product

/settings 而不是 /setting

### 使用子资源表达关系

如果一个资源与另外一个资源有关系，使用子资源：

GET /cars/711/drivers/ 返回car 711的所有司机

GET /cars/711/drivers/4 返回car 711的4号司机

### 过滤信息

如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。

下面是一些常见的参数：

- ?limit=10：指定返回记录的数量
- ?offset=10：指定返回记录的开始位置
- ?page=2&per_page=100：指定第几页，以及每页的记录数
- ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序
- ?animal_type_id=1：指定筛选条件

### 版本

一个设计误区，就是在URI中加入版本号：

```
　http://www.example.com/app/1.0/foo 
　http://www.example.com/app/1.1/foo 
　http://www.example.com/app/2.0/foo
```

因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分：

```
　Accept: vnd.example-com.foo+json; version=1.0 
　Accept: vnd.example-com.foo+json; version=1.1 
　Accept: vnd.example-com.foo+json; version=2.0
```

### 用Http状态码处理状态

.....

## 开发流程

- [ ] [强制] 先提供接口，在开发代码
- [ ] 提交代码，走通checkstyle校验
- [ ] 提交代码，使用ctrl +alt +l格式化代码