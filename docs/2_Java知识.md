## java
https://zhuanlan.zhihu.com/p/478777350
https://cloud.tencent.com/developer/article/2404124

java 四大接口类 Cloneable、Compareble、serialize、Runnable
java clone浅clone、深clone
db事务隔离机制 4
数据库acid机制、聚镞索引
分布式事务： 两阶段提交 2PC 、 TCC try-confirm-cancel 、本地消息表+MQ
分布式锁
CAP 理论 与 一致性协议； paxops\raft 原理， zookeeper 、etch、consul 背后原理都是
类加载机制、双亲委派；的加载失败、同一个类加载两次、动态代理崩了


tcp\三次握手、四次挥手等、udp
dns协议
cas
线程与进程区别
zap协议和选举机制过程
深度优先遍历、广度优先遍历

封装、多态、继承； 重载、重写
乐观锁、悲观锁、读写锁、共享锁、互斥锁、自旋锁、可重入锁、偏向锁、公平锁、非公平锁
类加载机制（加载、验证、准备、解析、初始化，每部分做了什么）
jvm 结构，垃圾回收算法、GC
锁、同步、信号灯、条件等  共享变量、wait/notify、condition 的 await/signal、父子线程可以通过 InhritableThreadLocal、消息队列
多线程、线程池
开发模式

引用的方式有哪些？如何用
hashmap底层原理、concurrenthashmap
io多路复用
堆和栈区别
java中异常机制
跳表的原理？为什么能近似二分搜索？
二叉树多个节点的最近公共祖先



微服务
服务注册与发现：你以为用Spring Cloud + Eureka就高枕无忧？高可用怎么做、服务发现延迟多大、Eureka挂了服务咋办？
熔断限流降级： Hystrix淘汰，Resilience4j上场。限流是限谁？基于QPS还是线程池？降级用fallback怎么写才能优雅？
API网关和统一鉴权： 你用Nginx搞反代，最多做个负载均衡。网关真正的价值是统一入口、权限验证、流量控制、灰度发布。

#### bio、nio、aio
BIO: BIO（Blocking I/O）阻塞式I/O模型是Java网络编程中最基本的一种I/O模型. ServerSocket
NIO: NIO（Non-blocking I/O）非阻塞式I/O模型是对BIO模型的改进. 在NIO模型中，所有的I/O操作都是非阻塞的，因此不需要为每个连接都创建一个独立的线程，而是可以通过一个线程处理多个连接；ServerSocketChannel、Selector、SocketChannel
AIO: AIO（Asynchronous I/O）异步I/O模型是在NIO模型的基础上又做了一些改进，它将I/O操作的具体实现委托给内核，直接由内核进行读写操作，当数据读写完成后再回调到应用层； AsynchronousServerSocketChannel、AsynchronousSocketChannel、CompletionHandler
零拷贝： 零拷贝技术指避免CPU从应用缓冲区向内核缓冲区拷贝数据的一种技术。在网络编程领域，零拷贝可以将数据直接从磁盘或网络适配器读入内存中，从而避免了CPU的复制操作，提高了数据传输效率。在JAVA中，可以使用NIO的FileChannel.transferTo()
https://cloud.tencent.com/developer/article/2280011?policyId=1003

#### RPC Netty NIO
Netty 使用 NIO 模式是主要如下原因： 比较熟知的多个分布式系统都使用 netty 进行通信，dubbo、 RocketMQ、Hadoop、 Avro RPC 、 Spark 、 Storm 、Flink、 Yarn 、 DolphinScheduler、Elasticsearch、ZooKeeper
相对 BIO 避免了频繁创建、销毁线程的开销，利用其IO 多路复用的优势提高线程利用率；节省资源开销，能提供高并发场景；
相对 AIO 与底层系统兼容性更好，实现落地难度相对较低；AIO API 复杂，使用回调模式易导致逻辑混乱，不易管理；


### spring、mybatis
原理、用到的模式、aop、ioa
spring循环依赖如何解决
spring三级缓存结构、用到的模式


### Redis
可做缓存也可做分布式锁；
做分布式锁时会有坑：锁超时问题、网络分区问题

数据库和缓存强一致性和弱一致性如何保证，列出各种情况（删除失败、更新失败等等）以及解决方案
缓存雪崩、缓存穿透、缓存击穿，该如何避免；
穿透：请求查不存在的key，一路打到DB，DB崩了。  布隆过滤器、互斥锁、随机过期时间
击穿：热点key突然失效，大量请求打到DB。   多级缓存设计：本地缓存 + 分布式缓存
雪崩：大量key同时过期，Redis直接废了。   预加载 + 异步刷新 + 限流降级

缓存与数据库的一致性：你能不能让缓存和DB在高并发下保持一致。
先删缓存？可能查到旧数据。
先更新缓存？数据还没落盘。
延时双删？看似完美，但容易忘。

Sentinel、Hystrix、RateLimiter、Resilience4j 熔断器

### 第三方本地开源缓存架构
* Guava Cache（谷歌出品，轻量且强大）： dolphinscheduler 中有使用
  支持基于容量的淘汰（设置最大缓存条目数，达到阈值自动淘汰）、基于时间的过期（访问过期、写入过期）；
  支持缓存加载策略（CacheLoader 实现缓存自动加载，解决缓存穿透）、异步刷新、移除监听器；
  天然线程安全，底层采用分段锁保证并发访问效率；
  提供缓存命中率统计，便于优化缓存策略。

* Ehcache（企业级全功能缓存，支持本地 + 分布式）：之前在 360 使用过，与 mybatis结合方便
  核心定位：功能最全面的 Java 缓存框架，支持「本地缓存」和「分布式缓存」双模，适合复杂企业级应用。
  核心特性：
  支持多级缓存（内存缓存 + 磁盘缓存），避免内存溢出，可持久化缓存数据；
  丰富的缓存淘汰策略（LRU、LFU、FIFO 等）、细粒度的过期配置；
  支持事务一致性、缓存集群、高可用，可无缝迁移至分布式缓存；
  与 Spring 框架深度集成，适合 Spring Boot/Spring Cloud 项目。

* Spring Cache（缓存抽象层，并非具体实现）
  核心定位：Spring 提供的缓存抽象框架，可整合上述所有本地缓存实现，简化缓存开发，降低耦合。
  核心特性：
  基于注解驱动（@Cacheable、@CachePut、@CacheEvict），无需手动操作缓存；
  可灵活切换底层缓存实现（Guava、Caffeine、Ehcache 等），无需修改业务代码；
  支持缓存分区、批量操作、自定义缓存键生成策略。

* Caffeine（新一代高性能缓存，替代 Guava Cache）：
  目前性能最优的 Java 本地缓存框架，缓存淘汰算法（W-TinyLFU）远超 Guava Cache，是大型应用、高并发场景的首选。
  性能极致：吞吐量和命中率比 Guava Cache 高出 10%-20%，底层采用更高效的并发数据结构；
  兼容 Guava Cache API：迁移成本极低，几乎可以直接替换 Guava Cache；
  支持异步加载、异步刷新、批量操作，以及更灵活的过期策略；
  支持缓存统计、自定义淘汰策略，线程安全且并发性能更优。

### 第三方本地数据库
#### H2 Database（最流行，开发 / 测试首选） DolphinScheduler 快速模式使用的该 db
核心定位：纯 Java 编写的开源嵌入式数据库，支持「嵌入式模式」「服务器模式」「内存模式」，功能全面、轻量级、易用性拉满，是 Java 项目开发、单元测试、小型应用的首选。
核心特性：
纯 Java 实现，跨平台，无需安装额外依赖，只需引入 Maven 包即可使用；
支持三种运行模式：
嵌入式模式（本地文件存储）：数据存储在本地磁盘文件，仅当前应用可访问，无网络开销；
内存模式（数据仅存内存）：应用重启后数据丢失，适合单元测试、临时数据存储；
服务器模式（支持远程访问）：可作为独立数据库服务运行，兼容 JDBC/ODBC，兼顾灵活性；
支持标准 SQL、事务（ACID）、索引、视图、存储过程，兼容 MySQL/Oracle 语法，迁移成本低；
自带可视化管理控制台，方便调试和数据查看；
体积小巧（核心包仅几百 KB），性能优异，对资源占用极低。
适用场景：Java 项目单元测试、小型桌面应用、嵌入式设备、临时数据存储、快速原型验证。

#### SQLite（跨平台之王，桌面 / 移动应用首选）
核心定位：开源、跨平台、无服务器的嵌入式数据库，并非纯 Java 实现（核心是 C 语言），但有优秀的 Java 驱动（SQLite JDBC）支持，是全球使用最广泛的嵌入式数据库。
核心特性：
跨平台性极强，支持 Windows、Linux、macOS、Android、iOS 等几乎所有平台，数据文件可跨平台迁移；
轻量级，单文件存储所有数据（无需额外配置文件），体积小（核心库仅几百 KB）；
支持标准 SQL、事务、索引、视图，兼容性好，对资源占用极低；
开源免费，社区活跃，文档完善，生态丰富；
缺点：Java 中需依赖原生驱动（部分平台可能需要适配），并发写入性能较弱（适合读多写少场景）。
适用场景：桌面应用（如办公软件、工具类程序）、移动应用（Android）、嵌入式设备、读多写少的小型应用、数据归档。

#### Derby（Apache 出品，纯 Java 企业级） hive metastore 默认 db
核心定位：Apache 开源的纯 Java 嵌入式数据库，又名 Java DB（被 Oracle 收录为 JDK 内置数据库），功能全面，企业级特性完善，适合对事务一致性要求较高的小型 Java 企业应用。
核心特性：
纯 Java 实现，跨平台，无需额外安装，JDK 1.6+ 内置（无需手动引入依赖，直接使用）；
支持「嵌入式模式」和「网络服务器模式」，切换灵活；
支持标准 SQL、事务（ACID）、分布式事务、索引、视图、存储过程、触发器，企业级特性完善；
线程安全，并发性能优于 SQLite，数据可靠性高；
缺点：体积相对较大，性能略逊于 H2，社区活跃度不如 H2/SQLite。
适用场景：Java 企业级小型应用、桌面应用、事务性应用、JDK 内置环境的快速开发、单元测试。

#### HSQLDB（HyperSQL，纯 Java 高性能）
核心定位：纯 Java 编写的开源嵌入式数据库，又名 Hypersonic SQL，高性能、功能丰富，支持多种运行模式，适合对性能要求较高的小型 Java 应用和框架底层。
核心特性：
纯 Java 实现，跨平台，支持嵌入式、服务器、内存三种运行模式；
支持标准 SQL、事务（ACID）、存储过程、触发器、索引、视图，兼容 MySQL/Oracle 语法；
性能优异，内存操作速度极快，适合高频读写的小型场景；
自带可视化管理工具，方便调试，常被作为开源框架的内置数据库（如 Spring、Hibernate 测试环境）；
缺点：文档相对简略，社区活跃度略低于 H2。
适用场景：Java 高性能小型应用、开源框架底层、单元测试、内存数据库场景、桌面应用。


#### BDB JE（Java 应用首选，重点详解） StarRocks FE 元数据存储中有使用
核心定位
Oracle 出品的开源纯 Java 嵌入式键值数据库，专注于 高性能、高可靠性、大容量 的本地数据存储，适合对读写吞吐量、数据持久性要求严苛的 Java 应用（如日志存储、配置缓存、嵌入式系统数据持久化），不适合需要 SQL 语法、关系型数据模型的场景。
核心特性
纯 Java 实现，零原生依赖：无需安装原生库，无需 JNI 调用，直接嵌入 JVM 进程，跨平台（Windows/Linux/macOS）无适配成本，部署简单。
极致性能：针对 Java 应用优化，支持百万级每秒读写吞吐量，延迟极低，适合高频次、高并发的 KV 数据操作（远超传统关系型嵌入式数据库）。
强大的持久性与可靠性：支持事务（ACID 特性）、崩溃恢复、数据备份与还原，支持多级缓存（内存 + 磁盘），数据持久化到本地文件，无数据丢失风险。
灵活的存储配置：支持自定义键值序列化方式、存储路径、缓存大小、事务隔离级别，支持批量操作、范围查询、游标遍历，满足复杂 KV 存储需求。
轻量级且可扩展：核心包体积较小（约几 MB），对资源占用低，支持单进程超大容量数据存储（可支持 TB 级数据）。
缺点：非关系型数据库，不支持 SQL 语法、视图、存储过程等关系型特性；学习成本略高于 H2，无可视化管理控制台，调试相对繁琐。



### Log4j

### Logback

